"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const joi_1 = __importDefault(require("@hapi/joi"));
const supertest_1 = __importDefault(require("supertest"));
const express_1 = __importDefault(require("express"));
const cookie_parser_1 = __importDefault(require("cookie-parser"));
const validation_middleware_1 = require("../../src/middlewares/validation.middleware");
describe('validatorMiddleware', () => {
    test('respond with validation error', () => __awaiter(void 0, void 0, void 0, function* () {
        const middleware = validation_middleware_1.buildValidationMiddleware({
            query: joi_1.default.object({
                foo: joi_1.default.string().required(),
            }),
        }, {
            message: 'MESSAGE',
            code: 'CODE',
        });
        const app = express_1.default().get('/', middleware);
        const { body, status } = yield supertest_1.default(app).get('/');
        expect(status).toEqual(400);
        expect(body).toEqual({
            message: 'MESSAGE',
            code: 'CODE',
            statusCode: 400,
            context: {
                validationErrors: [
                    {
                        name: 'foo',
                        message: '"query.foo" is required',
                        path: ['query', 'foo'],
                        type: 'any.required',
                    },
                ],
            },
        });
    }));
    test('validated request', () => __awaiter(void 0, void 0, void 0, function* () {
        const middleware = validation_middleware_1.buildValidationMiddleware({
            query: joi_1.default.object({
                foo: joi_1.default.string().required(),
            }),
        });
        const routeHandler = (request, response) => response.sendStatus(201);
        const app = express_1.default().get('/', middleware, routeHandler);
        const { body, status } = yield supertest_1.default(app).get('/?foo=bar');
        expect(body).toEqual({});
        expect(status).toBe(201);
    }));
    test('validated request with cookies if cookie parser is present', () => __awaiter(void 0, void 0, void 0, function* () {
        const middleware = validation_middleware_1.buildValidationMiddleware({
            query: joi_1.default.object({
                foo: joi_1.default.string().required(),
            }),
            cookies: joi_1.default.object({
                myCookie: joi_1.default.string().required(),
            }).required(),
        });
        const routeHandler = (request, response) => {
            return response.sendStatus(201);
        };
        const app = express_1.default()
            .use(cookie_parser_1.default())
            .get('/', middleware, routeHandler);
        const { body, status } = yield supertest_1.default(app)
            .get('/?foo=bar')
            .set('Cookie', ['myCookie=I_LOVE_COOKIES']);
        expect(body).toEqual({});
        expect(status).toBe(201);
    }));
    test('respond with validation error using validator builder function', () => __awaiter(void 0, void 0, void 0, function* () {
        const validatorBuilder = (options) => ({
            query: joi_1.default.object({
                foo: joi_1.default.string()
                    .required()
                    .messages({
                    'any.required': options.translate('X'),
                }),
            }),
        });
        const middleware = validation_middleware_1.buildValidationMiddleware(validatorBuilder);
        const translateMock = jest.fn().mockReturnValue('WOLOLOLO');
        const mockI18nMiddleware = (req, res, next) => {
            req.translate = translateMock;
            return next();
        };
        const app = express_1.default().get('/', mockI18nMiddleware, middleware);
        const { body, status } = yield supertest_1.default(app).get('/');
        expect(body).toEqual({
            message: 'Bad Request',
            code: 'bad-request',
            statusCode: 400,
            context: {
                validationErrors: [
                    {
                        name: 'foo',
                        message: 'WOLOLOLO',
                        path: ['query', 'foo'],
                        type: 'any.required',
                    },
                ],
            },
        });
        expect(status).toEqual(400);
        expect(translateMock).toBeCalledWith('X');
    }));
});
//# sourceMappingURL=validator.middleware.test.js.map